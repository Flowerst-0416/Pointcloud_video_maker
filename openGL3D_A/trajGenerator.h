#pragma once

#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <vector>

#include "utils.h"

/*
 * This class generates a trajectory for the camera to follow.
 * The trajectory is a curve through a set of key points.
 */
class trajGenerator {
private:
	double velocity = 1.0;         // velocity of the camera (pixels per frame)
	std::vector<Point> keyPoints;  // key points set by the user
	std::vector<Point> traj;       // trajectory generated by the algorithm

public:
	/*
	 * @brief: Set the velocity of the camera
	 * @param: v: speed of the camera (pixels per frame)
	 */
	void setVelocity(double v) { velocity = v; }

	/*
	 * @brief: Get the vector of key points
	 * @return: the vector of key points
	 */
	std::vector<Point> getKeyPoints() { return keyPoints; }

	/*
	 * @brief: Add a key point to the end of keyPoints vector
	 * @param: aPoint, a key point set by the user
	 * @return: void
	 */
	void addKeyPoint(Point aPoint) { keyPoints.push_back(aPoint); }

	/*
	 * @brief: Insert a key point into keyPoints vector
	 * @param: aPoint, a key point set by the user
	 * @param: index, the index of the key point
	 * @return: void
	 */
	void insertKeyPoint(Point aPoint, int index) { keyPoints.insert(keyPoints.begin() + index, aPoint); }

	/*
	 * @brief: Remove a key point from keyPoints
	 * @param: index, the index of the key point
	 * @return: void
	 */
	void removeKeyPoint(int index) { keyPoints.erase(keyPoints.begin() + index); }

	/*
	 * @brief: remove all key points
	 * @param: void
	 * @return: void
	 */
	void resetKeyPoints() { keyPoints.clear(); }

	/*
	 *@brief: Print all key points
	 *@param: void
	 *@return: void
	 */
	void printKeyPoints() {
		for (int i = 0; i < keyPoints.size(); i++) {
			// print the position of the key point
			std::cout << "Key point " << i << ": (" << keyPoints[i].pos.x << ", " << keyPoints[i].pos.y << ", " << keyPoints[i].pos.z << "), (";
			// print the quaternion of the key point
			// std::cout << keyPoints[i].quat.a << ", " << keyPoints[i].quat.b << ", " << keyPoints[i].quat.c << ", " << keyPoints[i].quat.d << ")" << std::endl;
			// print the Euler angles of the key point
			std::cout << keyPoints[i].roll << ", " << keyPoints[i].pitch << ", " << keyPoints[i].yaw << ")" << std::endl;
		}
	}

	/*
	 * @brief: Linearly interpolate some points between two key points
	 * @param: p1: the first key point
	 * @param: p2: the second key point
	 * @param: type: the type of interpolation (1: linear)
	 * @return: a vector of interpolated points
	 */
	std::vector<Point> linearInterpolate(Point p1, Point p2);

	/*
	 * @brief: Generate a cubic spline curve given a set of key points
	 * @param: void
	 * @return: a vector of points on the curve
	 */
	std::vector<Point> cubicSpline();

	/*
	 * @brief: Get the trajectory generated by the algorithm
	 * @param: void
	 * @return: traj, the trajectory generated by the algorithm
	 */
	std::vector<Point> getTraj() { return traj; }

	/*
	 * @brief: Generate a trajectory based on the key points
	 * @param: type: the type of interpolation (1: linear)
	 * @return: void
	 */
	void genTraj(int type);

	/*
	 * @brief: Reset the trajectory to default, which is a circle around the Z axis
	 * @param: void
	 * @return: void
	 */
	void resetTraj(double radius, double height);

	/*
	 * @brief: Print the trajectory
	 * @param: void
	 * @return: void
	 */
	void printTraj() {
		std::cout << "The trajectory: " << std::endl;
		for (int i = 0; i < traj.size(); i++) {
			// print the position of the key point
			std::cout << i << ": (" << traj[i].pos.x << ", " << traj[i].pos.y << ", " << traj[i].pos.z << "), (";
			// print the quaternion of the key point
			// std::cout << traj[i].quat.a << ", " << traj[i].quat.b << ", " << traj[i].quat.c << ", " << traj[i].quat.d << ")" << std::endl;
			// print the Euler angles of the key point
			std::cout << traj[i].roll << ", " << traj[i].pitch << ", " << traj[i].yaw << ")" << std::endl;
		}
	}
};